module.exports =
/******/ (function (modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if (installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
                /******/
}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
                /******/
};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
            /******/
}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function (exports, name, getter) {
/******/ 		if (!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
                /******/
}
            /******/
};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function (exports) {
/******/ 		if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
                /******/
}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
            /******/
};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function (value, mode) {
/******/ 		if (mode & 1) value = __webpack_require__(value);
/******/ 		if (mode & 8) return value;
/******/ 		if ((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if (mode & 2 && typeof value != 'string') for (var key in value) __webpack_require__.d(ns, key, function (key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
            /******/
};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function (module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
            /******/
};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function (object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.ts");
        /******/
})
/************************************************************************/
/******/({

/***/ "./src/action-executor.ts":
/*!********************************!*\
  !*** ./src/action-executor.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

                    "use strict";

                    Object.defineProperty(exports, "__esModule", { value: true });
                    const utils_1 = __webpack_require__(/*! ./utils */ "./src/utils.ts");
                    class ActionExecutor {
                        constructor(discordMessage) {
                            this.discordMessage = discordMessage;
                        }
                        replySameChannel(text) {
                            this.discordMessage.channel.send(text);
                        }
                        reply(args) {
                            this.replySameChannel(args[0]);
                        }
                        replySometimes(args) {
                            if (utils_1.Utils.random(1, 100) <= args[1]) {
                                this.replySameChannel(args[0]);
                            }
                        }
                        replyOne(args) {
                            this.replySameChannel(utils_1.Utils.randomItem(args));
                        }
                        then(callback) {
                            callback(this.discordMessage);
                        }
                        do(callback, matches, minArgs, errorMessage) {
                            var minimumArgs = minArgs || 0;
                            let args = this.discordMessage.content.trim().split(" ");
                            // Remove command from args
                            args.splice(0, 1);
                            let rawArgs = args.join(" ");

                            console.log("excecuting do, matches: ", matches)
                            var pattern = new RegExp(matches)
                            if ((args.length < minimumArgs || !pattern.test(this.discordMessage.content)) && errorMessage) {
                                this.replySameChannel(errorMessage);
                            }
                            else {
                                callback(args, rawArgs, this.discordMessage);
                            }
                        }
                    }
                    exports.ActionExecutor = ActionExecutor;


                    /***/
}),

/***/ "./src/handler-builder.ts":
/*!********************************!*\
  !*** ./src/handler-builder.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

                    "use strict";

                    Object.defineProperty(exports, "__esModule", { value: true });
                    const utils_1 = __webpack_require__(/*! ./utils */ "./src/utils.ts");
                    class HandlerConfig {
                    }
                    exports.HandlerConfig = HandlerConfig;
                    class HandlerBuilder {
                        constructor() {
                            this.handler = new HandlerConfig();
                        }
                        type(type) {
                            this.handler.type = type;
                            return this;
                        }
                        query(query) {
                            this.handler.query = query;
                            return this;
                        }
                        reply(text) {
                            this.handler.action = utils_1.ActionType.REPLY;
                            this.handler.actionArgs = [text];
                        }
                        /**
                         * @deprecated Use `sometimes(chance)` instead.
                         */
                        replySometimes(text, chance) {
                            this.handler.action = utils_1.ActionType.REPLY_SOMETIMES;
                            this.handler.actionArgs = [text, chance];
                        }
                        replyOne(array) {
                            this.handler.action = utils_1.ActionType.REPLY_ONE;
                            this.handler.actionArgs = array;
                        }
                        then(callback) {
                            this.handler.action = utils_1.ActionType.THEN;
                            this.handler.callback = callback;
                        }
                        do(callback) {
                            this.handler.action = utils_1.ActionType.DO;
                            this.handler.callback = callback;
                        }
                        minArgs(count) {
                            this.handler.minArgs = count;
                            return this;
                        }
                        matches(regex) {
                            this.handler.matches = regex
                            return this;
                        }
                        alias(alt) {
                            if (this.handler.aliases) {
                                this.handler.aliases.push(alt);
                            }
                            else {
                                this.handler.aliases = [alt];
                            }
                            return this;
                        }
                        whenInvalid(message) {
                            this.handler.errorMessage = message;
                            return this;
                        }
                        sometimes(chance) {
                            this.handler.chance = chance;
                            return this;
                        }
                        /**
                         * Delete the message that triggered this command
                         * @param time Time in milliseconds
                         */
                        deleteInvocation(time) {
                            this.handler.deleteTimer = time || 0;
                            return this;
                        }
                    }
                    exports.HandlerBuilder = HandlerBuilder;


                    /***/
}),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

                    "use strict";

                    Object.defineProperty(exports, "__esModule", { value: true });
                    const handler_builder_1 = __webpack_require__(/*! ./handler-builder */ "./src/handler-builder.ts");
                    const utils_1 = __webpack_require__(/*! ./utils */ "./src/utils.ts");
                    const action_executor_1 = __webpack_require__(/*! ./action-executor */ "./src/action-executor.ts");
                    class MessageHandler {
                        constructor(context) {
                            this.handlers = [];
                            this.caseSensitive = false;
                            this.logFn = null;
                            if (context) {
                                this.handlers = context.handlers;
                                this.caseSensitive = context.caseSensitive;
                                this.logFn = context.logFn;
                            }
                        }
                        log(messageType, filter, message) {
                            const msgType = utils_1.Utils.getKeyByValue(utils_1.MessageType, messageType);
                            if (this.logFn && typeof this.logFn == "function") {
                                this.logFn(msgType, filter, message);
                            }
                        }
                        setCaseSensitive(isCaseSensitive) {
                            this.caseSensitive = isCaseSensitive;
                        }
                        enableLogging(logFn) {
                            this.logFn = logFn;
                        }
                        whenMessageContains(text) {
                            const builder = new handler_builder_1.HandlerBuilder().type(utils_1.MessageType.MESSAGE_CONTAINS).query(text);
                            this.handlers.push(builder);
                            return builder;
                        }
                        whenMessageContainsExact(text) {
                            const builder = new handler_builder_1.HandlerBuilder().type(utils_1.MessageType.MESSAGE_CONTAINS_EXACT).query(text);
                            this.handlers.push(builder);
                            return builder;
                        }
                        whenMessageContainsWord(text) {
                            const builder = new handler_builder_1.HandlerBuilder().type(utils_1.MessageType.MESSAGE_CONTAINS_WORD).query(text);
                            this.handlers.push(builder);
                            return builder;
                        }
                        whenMessageContainsOne(array) {
                            const builder = new handler_builder_1.HandlerBuilder().type(utils_1.MessageType.MESSAGE_CONTAINS_ONE).query(array);
                            this.handlers.push(builder);
                            return builder;
                        }
                        whenMessageStartsWith(text) {
                            const builder = new handler_builder_1.HandlerBuilder().type(utils_1.MessageType.MESSAGE_STARTS_WITH).query(text);
                            this.handlers.push(builder);
                            return builder;
                        }
                        whenMessageEndsWith(text) {
                            const builder = new handler_builder_1.HandlerBuilder().type(utils_1.MessageType.MESSAGE_ENDS_WITH).query(text);
                            this.handlers.push(builder);
                            return builder;
                        }
                        onCommand(text) {
                            const builder = new handler_builder_1.HandlerBuilder().type(utils_1.MessageType.COMMAND).query(text);
                            this.handlers.push(builder);
                            return builder;
                        }
                        handleMessage(discordMessage) {
                            const messageRaw = discordMessage.content;
                            this.handlers
                                .map(builder => builder.handler)
                                .filter(handler => {
                                    let message;
                                    let query;
                                    if (this.caseSensitive) {
                                        message = discordMessage.content;
                                        query = handler.query;
                                    }
                                    else {
                                        message = discordMessage.content.toLowerCase();
                                        if (Array.isArray(handler.query)) {
                                            query = utils_1.Utils.arrayToLower(handler.query);
                                        }
                                        else {
                                            query = handler.query.toLowerCase();
                                        }
                                    }
                                    switch (handler.type) {
                                        case utils_1.MessageType.MESSAGE_CONTAINS:
                                            return message.includes(query);
                                        case utils_1.MessageType.MESSAGE_CONTAINS_EXACT:
                                            return messageRaw.includes(handler.query);
                                        case utils_1.MessageType.MESSAGE_CONTAINS_WORD:
                                            return message.split(" ").indexOf(query) >= 0;
                                        case utils_1.MessageType.MESSAGE_CONTAINS_ONE:
                                            return query.filter(queryParam => message.split(" ").indexOf(queryParam) >= 0).length > 0;
                                        case utils_1.MessageType.MESSAGE_STARTS_WITH:
                                        case utils_1.MessageType.COMMAND:
                                            if (handler.aliases) {
                                                handler.aliases.push(query);
                                                let check = handler.aliases.map(q => utils_1.Utils.startsWithWord(message, q));
                                                return check.reduce((a, b) => a || b);
                                            }
                                            else {
                                                return utils_1.Utils.startsWithWord(message, query);
                                            }
                                        case utils_1.MessageType.MESSAGE_ENDS_WITH:
                                            return message.endsWith(query);
                                        default:
                                            return false;
                                    }
                                })
                                .forEach((handler) => {
                                    this.log(handler.type, handler.query.toString(), discordMessage);
                                    let executor = new action_executor_1.ActionExecutor(discordMessage);
                                    if (this.checkChance(handler)) {
                                        switch (handler.action) {
                                            case utils_1.ActionType.REPLY:
                                                executor.reply(handler.actionArgs);
                                                break;
                                            case utils_1.ActionType.REPLY_SOMETIMES:
                                                executor.replySometimes(handler.actionArgs);
                                                break;
                                            case utils_1.ActionType.REPLY_ONE:
                                                executor.replyOne(handler.actionArgs);
                                                break;
                                            case utils_1.ActionType.THEN:
                                                executor.then(handler.callback);
                                                break;
                                            case utils_1.ActionType.DO:
                                                executor.do(handler.callback, handler.matches, handler.minArgs, handler.errorMessage);
                                                break;
                                            default:
                                                break;
                                        }
                                        this.checkDeletion(handler, discordMessage);
                                    }
                                    else {
                                        this.log(utils_1.MessageType.CANCELLED, "Action failed the 'sometimes' chance.", discordMessage);
                                    }
                                });
                        }
                        checkChance(handler) {
                            if (handler && handler.chance) {
                                return utils_1.Utils.random(1, 100) <= handler.chance;
                            }
                            else {
                                return true;
                            }
                        }
                        checkDeletion(handler, message) {
                            if (handler.deleteTimer != null) {
                                setTimeout(() => {
                                    message.delete();
                                }, handler.deleteTimer);
                            }
                        }
                    }
                    exports.MessageHandler = MessageHandler;


                    /***/
}),

/***/ "./src/utils.ts":
/*!**********************!*\
  !*** ./src/utils.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

                    "use strict";

                    Object.defineProperty(exports, "__esModule", { value: true });
                    exports.MessageType = {
                        CANCELLED: -1,
                        MESSAGE_CONTAINS: 0,
                        MESSAGE_CONTAINS_EXACT: 1,
                        MESSAGE_CONTAINS_WORD: 2,
                        MESSAGE_CONTAINS_ONE: 3,
                        MESSAGE_STARTS_WITH: 4,
                        MESSAGE_ENDS_WITH: 5,
                        COMMAND: 6
                    };
                    exports.ActionType = {
                        REPLY: 0,
                        REPLY_SOMETIMES: 1,
                        REPLY_ONE: 2,
                        THEN: 3,
                        DO: 4
                    };
                    class Utils {
                        static random(min, max) {
                            return Math.floor(Math.random() * (max - min + 1) + min);
                        }
                        static randomItem(array) {
                            return array[Utils.random(0, array.length - 1)];
                        }
                        static arrayToLower(array) {
                            return array.map(str => str.toLowerCase());
                        }
                        static startsWithWord(str, search) {
                            return ((str.length == search.length) && (str == search)) ||
                                ((str.length > search.length) && (str.startsWith(search + ' ')));
                        }
                        static getKeyByValue(obj, value) {
                            for (let prop in obj) {
                                if (obj.hasOwnProperty(prop)) {
                                    if (obj[prop] === value)
                                        return prop;
                                }
                            }
                            return null;
                        }
                    }
                    exports.Utils = Utils;


                    /***/
})

            /******/
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FjdGlvbi1leGVjdXRvci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvaGFuZGxlci1idWlsZGVyLnRzIiwid2VicGFjazovLy8uL3NyYy9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtEQUEwQyxnQ0FBZ0M7QUFDMUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnRUFBd0Qsa0JBQWtCO0FBQzFFO0FBQ0EseURBQWlELGNBQWM7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUF5QyxpQ0FBaUM7QUFDMUUsd0hBQWdILG1CQUFtQixFQUFFO0FBQ3JJO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwrREFBK0Q7O0FBRXJIO0FBQ0E7OztBQUdBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNsRkE7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3RDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdkVBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDMUpBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImluZGV4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9zcmMvaW5kZXgudHNcIik7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmNsYXNzIEFjdGlvbkV4ZWN1dG9yIHtcbiAgICBjb25zdHJ1Y3RvcihkaXNjb3JkTWVzc2FnZSkge1xuICAgICAgICB0aGlzLmRpc2NvcmRNZXNzYWdlID0gZGlzY29yZE1lc3NhZ2U7XG4gICAgfVxuICAgIHJlcGx5U2FtZUNoYW5uZWwodGV4dCkge1xuICAgICAgICB0aGlzLmRpc2NvcmRNZXNzYWdlLmNoYW5uZWwuc2VuZCh0ZXh0KTtcbiAgICB9XG4gICAgcmVwbHkoYXJncykge1xuICAgICAgICB0aGlzLnJlcGx5U2FtZUNoYW5uZWwoYXJnc1swXSk7XG4gICAgfVxuICAgIHJlcGx5U29tZXRpbWVzKGFyZ3MpIHtcbiAgICAgICAgaWYgKHV0aWxzXzEuVXRpbHMucmFuZG9tKDEsIDEwMCkgPD0gYXJnc1sxXSkge1xuICAgICAgICAgICAgdGhpcy5yZXBseVNhbWVDaGFubmVsKGFyZ3NbMF0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlcGx5T25lKGFyZ3MpIHtcbiAgICAgICAgdGhpcy5yZXBseVNhbWVDaGFubmVsKHV0aWxzXzEuVXRpbHMucmFuZG9tSXRlbShhcmdzKSk7XG4gICAgfVxuICAgIHRoZW4oY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sodGhpcy5kaXNjb3JkTWVzc2FnZSk7XG4gICAgfVxuICAgIGRvKGNhbGxiYWNrLCBtaW5BcmdzLCBlcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIG1pbmltdW1BcmdzID0gbWluQXJncyB8fCAwO1xuICAgICAgICBsZXQgYXJncyA9IHRoaXMuZGlzY29yZE1lc3NhZ2UuY29udGVudC50cmltKCkuc3BsaXQoXCIgXCIpO1xuICAgICAgICAvLyBSZW1vdmUgY29tbWFuZCBmcm9tIGFyZ3NcbiAgICAgICAgYXJncy5zcGxpY2UoMCwgMSk7XG4gICAgICAgIGxldCByYXdBcmdzID0gYXJncy5qb2luKFwiIFwiKTtcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDwgbWluaW11bUFyZ3MgJiYgZXJyb3JNZXNzYWdlKSB7XG4gICAgICAgICAgICB0aGlzLnJlcGx5U2FtZUNoYW5uZWwoZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3MsIHJhd0FyZ3MsIHRoaXMuZGlzY29yZE1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5BY3Rpb25FeGVjdXRvciA9IEFjdGlvbkV4ZWN1dG9yO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5jbGFzcyBIYW5kbGVyQ29uZmlnIHtcbn1cbmV4cG9ydHMuSGFuZGxlckNvbmZpZyA9IEhhbmRsZXJDb25maWc7XG5jbGFzcyBIYW5kbGVyQnVpbGRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlciA9IG5ldyBIYW5kbGVyQ29uZmlnKCk7XG4gICAgfVxuICAgIHR5cGUodHlwZSkge1xuICAgICAgICB0aGlzLmhhbmRsZXIudHlwZSA9IHR5cGU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBxdWVyeShxdWVyeSkge1xuICAgICAgICB0aGlzLmhhbmRsZXIucXVlcnkgPSBxdWVyeTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJlcGx5KHRleHQpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVyLmFjdGlvbiA9IHV0aWxzXzEuQWN0aW9uVHlwZS5SRVBMWTtcbiAgICAgICAgdGhpcy5oYW5kbGVyLmFjdGlvbkFyZ3MgPSBbdGV4dF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBgc29tZXRpbWVzKGNoYW5jZSlgIGluc3RlYWQuXG4gICAgICovXG4gICAgcmVwbHlTb21ldGltZXModGV4dCwgY2hhbmNlKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlci5hY3Rpb24gPSB1dGlsc18xLkFjdGlvblR5cGUuUkVQTFlfU09NRVRJTUVTO1xuICAgICAgICB0aGlzLmhhbmRsZXIuYWN0aW9uQXJncyA9IFt0ZXh0LCBjaGFuY2VdO1xuICAgIH1cbiAgICByZXBseU9uZShhcnJheSkge1xuICAgICAgICB0aGlzLmhhbmRsZXIuYWN0aW9uID0gdXRpbHNfMS5BY3Rpb25UeXBlLlJFUExZX09ORTtcbiAgICAgICAgdGhpcy5oYW5kbGVyLmFjdGlvbkFyZ3MgPSBhcnJheTtcbiAgICB9XG4gICAgdGhlbihjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmhhbmRsZXIuYWN0aW9uID0gdXRpbHNfMS5BY3Rpb25UeXBlLlRIRU47XG4gICAgICAgIHRoaXMuaGFuZGxlci5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cbiAgICBkbyhjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmhhbmRsZXIuYWN0aW9uID0gdXRpbHNfMS5BY3Rpb25UeXBlLkRPO1xuICAgICAgICB0aGlzLmhhbmRsZXIuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG4gICAgbWluQXJncyhjb3VudCkge1xuICAgICAgICB0aGlzLmhhbmRsZXIubWluQXJncyA9IGNvdW50O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYWxpYXMoYWx0KSB7XG4gICAgICAgIGlmICh0aGlzLmhhbmRsZXIuYWxpYXNlcykge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVyLmFsaWFzZXMucHVzaChhbHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVyLmFsaWFzZXMgPSBbYWx0XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgd2hlbkludmFsaWQobWVzc2FnZSkge1xuICAgICAgICB0aGlzLmhhbmRsZXIuZXJyb3JNZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHNvbWV0aW1lcyhjaGFuY2UpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVyLmNoYW5jZSA9IGNoYW5jZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSB0aGUgbWVzc2FnZSB0aGF0IHRyaWdnZXJlZCB0aGlzIGNvbW1hbmRcbiAgICAgKiBAcGFyYW0gdGltZSBUaW1lIGluIG1pbGxpc2Vjb25kc1xuICAgICAqL1xuICAgIGRlbGV0ZUludm9jYXRpb24odGltZSkge1xuICAgICAgICB0aGlzLmhhbmRsZXIuZGVsZXRlVGltZXIgPSB0aW1lIHx8IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbmV4cG9ydHMuSGFuZGxlckJ1aWxkZXIgPSBIYW5kbGVyQnVpbGRlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgaGFuZGxlcl9idWlsZGVyXzEgPSByZXF1aXJlKFwiLi9oYW5kbGVyLWJ1aWxkZXJcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5jb25zdCBhY3Rpb25fZXhlY3V0b3JfMSA9IHJlcXVpcmUoXCIuL2FjdGlvbi1leGVjdXRvclwiKTtcbmNsYXNzIE1lc3NhZ2VIYW5kbGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaGFuZGxlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5jYXNlU2Vuc2l0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMubG9nRm4gPSBudWxsO1xuICAgICAgICBpZiAoY29udGV4dCkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVycyA9IGNvbnRleHQuaGFuZGxlcnM7XG4gICAgICAgICAgICB0aGlzLmNhc2VTZW5zaXRpdmUgPSBjb250ZXh0LmNhc2VTZW5zaXRpdmU7XG4gICAgICAgICAgICB0aGlzLmxvZ0ZuID0gY29udGV4dC5sb2dGbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsb2cobWVzc2FnZVR5cGUsIGZpbHRlciwgbWVzc2FnZSkge1xuICAgICAgICBjb25zdCBtc2dUeXBlID0gdXRpbHNfMS5VdGlscy5nZXRLZXlCeVZhbHVlKHV0aWxzXzEuTWVzc2FnZVR5cGUsIG1lc3NhZ2VUeXBlKTtcbiAgICAgICAgaWYgKHRoaXMubG9nRm4gJiYgdHlwZW9mIHRoaXMubG9nRm4gPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ0ZuKG1zZ1R5cGUsIGZpbHRlciwgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0Q2FzZVNlbnNpdGl2ZShpc0Nhc2VTZW5zaXRpdmUpIHtcbiAgICAgICAgdGhpcy5jYXNlU2Vuc2l0aXZlID0gaXNDYXNlU2Vuc2l0aXZlO1xuICAgIH1cbiAgICBlbmFibGVMb2dnaW5nKGxvZ0ZuKSB7XG4gICAgICAgIHRoaXMubG9nRm4gPSBsb2dGbjtcbiAgICB9XG4gICAgd2hlbk1lc3NhZ2VDb250YWlucyh0ZXh0KSB7XG4gICAgICAgIGNvbnN0IGJ1aWxkZXIgPSBuZXcgaGFuZGxlcl9idWlsZGVyXzEuSGFuZGxlckJ1aWxkZXIoKS50eXBlKHV0aWxzXzEuTWVzc2FnZVR5cGUuTUVTU0FHRV9DT05UQUlOUykucXVlcnkodGV4dCk7XG4gICAgICAgIHRoaXMuaGFuZGxlcnMucHVzaChidWlsZGVyKTtcbiAgICAgICAgcmV0dXJuIGJ1aWxkZXI7XG4gICAgfVxuICAgIHdoZW5NZXNzYWdlQ29udGFpbnNFeGFjdCh0ZXh0KSB7XG4gICAgICAgIGNvbnN0IGJ1aWxkZXIgPSBuZXcgaGFuZGxlcl9idWlsZGVyXzEuSGFuZGxlckJ1aWxkZXIoKS50eXBlKHV0aWxzXzEuTWVzc2FnZVR5cGUuTUVTU0FHRV9DT05UQUlOU19FWEFDVCkucXVlcnkodGV4dCk7XG4gICAgICAgIHRoaXMuaGFuZGxlcnMucHVzaChidWlsZGVyKTtcbiAgICAgICAgcmV0dXJuIGJ1aWxkZXI7XG4gICAgfVxuICAgIHdoZW5NZXNzYWdlQ29udGFpbnNXb3JkKHRleHQpIHtcbiAgICAgICAgY29uc3QgYnVpbGRlciA9IG5ldyBoYW5kbGVyX2J1aWxkZXJfMS5IYW5kbGVyQnVpbGRlcigpLnR5cGUodXRpbHNfMS5NZXNzYWdlVHlwZS5NRVNTQUdFX0NPTlRBSU5TX1dPUkQpLnF1ZXJ5KHRleHQpO1xuICAgICAgICB0aGlzLmhhbmRsZXJzLnB1c2goYnVpbGRlcik7XG4gICAgICAgIHJldHVybiBidWlsZGVyO1xuICAgIH1cbiAgICB3aGVuTWVzc2FnZUNvbnRhaW5zT25lKGFycmF5KSB7XG4gICAgICAgIGNvbnN0IGJ1aWxkZXIgPSBuZXcgaGFuZGxlcl9idWlsZGVyXzEuSGFuZGxlckJ1aWxkZXIoKS50eXBlKHV0aWxzXzEuTWVzc2FnZVR5cGUuTUVTU0FHRV9DT05UQUlOU19PTkUpLnF1ZXJ5KGFycmF5KTtcbiAgICAgICAgdGhpcy5oYW5kbGVycy5wdXNoKGJ1aWxkZXIpO1xuICAgICAgICByZXR1cm4gYnVpbGRlcjtcbiAgICB9XG4gICAgd2hlbk1lc3NhZ2VTdGFydHNXaXRoKHRleHQpIHtcbiAgICAgICAgY29uc3QgYnVpbGRlciA9IG5ldyBoYW5kbGVyX2J1aWxkZXJfMS5IYW5kbGVyQnVpbGRlcigpLnR5cGUodXRpbHNfMS5NZXNzYWdlVHlwZS5NRVNTQUdFX1NUQVJUU19XSVRIKS5xdWVyeSh0ZXh0KTtcbiAgICAgICAgdGhpcy5oYW5kbGVycy5wdXNoKGJ1aWxkZXIpO1xuICAgICAgICByZXR1cm4gYnVpbGRlcjtcbiAgICB9XG4gICAgd2hlbk1lc3NhZ2VFbmRzV2l0aCh0ZXh0KSB7XG4gICAgICAgIGNvbnN0IGJ1aWxkZXIgPSBuZXcgaGFuZGxlcl9idWlsZGVyXzEuSGFuZGxlckJ1aWxkZXIoKS50eXBlKHV0aWxzXzEuTWVzc2FnZVR5cGUuTUVTU0FHRV9FTkRTX1dJVEgpLnF1ZXJ5KHRleHQpO1xuICAgICAgICB0aGlzLmhhbmRsZXJzLnB1c2goYnVpbGRlcik7XG4gICAgICAgIHJldHVybiBidWlsZGVyO1xuICAgIH1cbiAgICBvbkNvbW1hbmQodGV4dCkge1xuICAgICAgICBjb25zdCBidWlsZGVyID0gbmV3IGhhbmRsZXJfYnVpbGRlcl8xLkhhbmRsZXJCdWlsZGVyKCkudHlwZSh1dGlsc18xLk1lc3NhZ2VUeXBlLkNPTU1BTkQpLnF1ZXJ5KHRleHQpO1xuICAgICAgICB0aGlzLmhhbmRsZXJzLnB1c2goYnVpbGRlcik7XG4gICAgICAgIHJldHVybiBidWlsZGVyO1xuICAgIH1cbiAgICBoYW5kbGVNZXNzYWdlKGRpc2NvcmRNZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VSYXcgPSBkaXNjb3JkTWVzc2FnZS5jb250ZW50O1xuICAgICAgICB0aGlzLmhhbmRsZXJzXG4gICAgICAgICAgICAubWFwKGJ1aWxkZXIgPT4gYnVpbGRlci5oYW5kbGVyKVxuICAgICAgICAgICAgLmZpbHRlcihoYW5kbGVyID0+IHtcbiAgICAgICAgICAgIGxldCBtZXNzYWdlO1xuICAgICAgICAgICAgbGV0IHF1ZXJ5O1xuICAgICAgICAgICAgaWYgKHRoaXMuY2FzZVNlbnNpdGl2ZSkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBkaXNjb3JkTWVzc2FnZS5jb250ZW50O1xuICAgICAgICAgICAgICAgIHF1ZXJ5ID0gaGFuZGxlci5xdWVyeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBkaXNjb3JkTWVzc2FnZS5jb250ZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlci5xdWVyeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcXVlcnkgPSB1dGlsc18xLlV0aWxzLmFycmF5VG9Mb3dlcihoYW5kbGVyLnF1ZXJ5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5ID0gaGFuZGxlci5xdWVyeS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAoaGFuZGxlci50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSB1dGlsc18xLk1lc3NhZ2VUeXBlLk1FU1NBR0VfQ09OVEFJTlM6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlLmluY2x1ZGVzKHF1ZXJ5KTtcbiAgICAgICAgICAgICAgICBjYXNlIHV0aWxzXzEuTWVzc2FnZVR5cGUuTUVTU0FHRV9DT05UQUlOU19FWEFDVDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2VSYXcuaW5jbHVkZXMoaGFuZGxlci5xdWVyeSk7XG4gICAgICAgICAgICAgICAgY2FzZSB1dGlsc18xLk1lc3NhZ2VUeXBlLk1FU1NBR0VfQ09OVEFJTlNfV09SRDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2Uuc3BsaXQoXCIgXCIpLmluZGV4T2YocXVlcnkpID49IDA7XG4gICAgICAgICAgICAgICAgY2FzZSB1dGlsc18xLk1lc3NhZ2VUeXBlLk1FU1NBR0VfQ09OVEFJTlNfT05FOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcXVlcnkuZmlsdGVyKHF1ZXJ5UGFyYW0gPT4gbWVzc2FnZS5zcGxpdChcIiBcIikuaW5kZXhPZihxdWVyeVBhcmFtKSA+PSAwKS5sZW5ndGggPiAwO1xuICAgICAgICAgICAgICAgIGNhc2UgdXRpbHNfMS5NZXNzYWdlVHlwZS5NRVNTQUdFX1NUQVJUU19XSVRIOlxuICAgICAgICAgICAgICAgIGNhc2UgdXRpbHNfMS5NZXNzYWdlVHlwZS5DT01NQU5EOlxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5hbGlhc2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLmFsaWFzZXMucHVzaChxdWVyeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY2hlY2sgPSBoYW5kbGVyLmFsaWFzZXMubWFwKHEgPT4gdXRpbHNfMS5VdGlscy5zdGFydHNXaXRoV29yZChtZXNzYWdlLCBxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hlY2sucmVkdWNlKChhLCBiKSA9PiBhIHx8IGIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHV0aWxzXzEuVXRpbHMuc3RhcnRzV2l0aFdvcmQobWVzc2FnZSwgcXVlcnkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSB1dGlsc18xLk1lc3NhZ2VUeXBlLk1FU1NBR0VfRU5EU19XSVRIOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZS5lbmRzV2l0aChxdWVyeSk7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAgICAgLmZvckVhY2goKGhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgIHRoaXMubG9nKGhhbmRsZXIudHlwZSwgaGFuZGxlci5xdWVyeS50b1N0cmluZygpLCBkaXNjb3JkTWVzc2FnZSk7XG4gICAgICAgICAgICBsZXQgZXhlY3V0b3IgPSBuZXcgYWN0aW9uX2V4ZWN1dG9yXzEuQWN0aW9uRXhlY3V0b3IoZGlzY29yZE1lc3NhZ2UpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY2hlY2tDaGFuY2UoaGFuZGxlcikpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGhhbmRsZXIuYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdXRpbHNfMS5BY3Rpb25UeXBlLlJFUExZOlxuICAgICAgICAgICAgICAgICAgICAgICAgZXhlY3V0b3IucmVwbHkoaGFuZGxlci5hY3Rpb25BcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHV0aWxzXzEuQWN0aW9uVHlwZS5SRVBMWV9TT01FVElNRVM6XG4gICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRvci5yZXBseVNvbWV0aW1lcyhoYW5kbGVyLmFjdGlvbkFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdXRpbHNfMS5BY3Rpb25UeXBlLlJFUExZX09ORTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dG9yLnJlcGx5T25lKGhhbmRsZXIuYWN0aW9uQXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSB1dGlsc18xLkFjdGlvblR5cGUuVEhFTjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dG9yLnRoZW4oaGFuZGxlci5jYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSB1dGlsc18xLkFjdGlvblR5cGUuRE86XG4gICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRvci5kbyhoYW5kbGVyLmNhbGxiYWNrLCBoYW5kbGVyLm1pbkFyZ3MsIGhhbmRsZXIuZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tEZWxldGlvbihoYW5kbGVyLCBkaXNjb3JkTWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZyh1dGlsc18xLk1lc3NhZ2VUeXBlLkNBTkNFTExFRCwgXCJBY3Rpb24gZmFpbGVkIHRoZSAnc29tZXRpbWVzJyBjaGFuY2UuXCIsIGRpc2NvcmRNZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNoZWNrQ2hhbmNlKGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKGhhbmRsZXIgJiYgaGFuZGxlci5jaGFuY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB1dGlsc18xLlV0aWxzLnJhbmRvbSgxLCAxMDApIDw9IGhhbmRsZXIuY2hhbmNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tEZWxldGlvbihoYW5kbGVyLCBtZXNzYWdlKSB7XG4gICAgICAgIGlmIChoYW5kbGVyLmRlbGV0ZVRpbWVyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGVsZXRlKCk7XG4gICAgICAgICAgICB9LCBoYW5kbGVyLmRlbGV0ZVRpbWVyKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuTWVzc2FnZUhhbmRsZXIgPSBNZXNzYWdlSGFuZGxlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NZXNzYWdlVHlwZSA9IHtcbiAgICBDQU5DRUxMRUQ6IC0xLFxuICAgIE1FU1NBR0VfQ09OVEFJTlM6IDAsXG4gICAgTUVTU0FHRV9DT05UQUlOU19FWEFDVDogMSxcbiAgICBNRVNTQUdFX0NPTlRBSU5TX1dPUkQ6IDIsXG4gICAgTUVTU0FHRV9DT05UQUlOU19PTkU6IDMsXG4gICAgTUVTU0FHRV9TVEFSVFNfV0lUSDogNCxcbiAgICBNRVNTQUdFX0VORFNfV0lUSDogNSxcbiAgICBDT01NQU5EOiA2XG59O1xuZXhwb3J0cy5BY3Rpb25UeXBlID0ge1xuICAgIFJFUExZOiAwLFxuICAgIFJFUExZX1NPTUVUSU1FUzogMSxcbiAgICBSRVBMWV9PTkU6IDIsXG4gICAgVEhFTjogMyxcbiAgICBETzogNFxufTtcbmNsYXNzIFV0aWxzIHtcbiAgICBzdGF0aWMgcmFuZG9tKG1pbiwgbWF4KSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkgKyBtaW4pO1xuICAgIH1cbiAgICBzdGF0aWMgcmFuZG9tSXRlbShhcnJheSkge1xuICAgICAgICByZXR1cm4gYXJyYXlbVXRpbHMucmFuZG9tKDAsIGFycmF5Lmxlbmd0aCAtIDEpXTtcbiAgICB9XG4gICAgc3RhdGljIGFycmF5VG9Mb3dlcihhcnJheSkge1xuICAgICAgICByZXR1cm4gYXJyYXkubWFwKHN0ciA9PiBzdHIudG9Mb3dlckNhc2UoKSk7XG4gICAgfVxuICAgIHN0YXRpYyBzdGFydHNXaXRoV29yZChzdHIsIHNlYXJjaCkge1xuICAgICAgICByZXR1cm4gKChzdHIubGVuZ3RoID09IHNlYXJjaC5sZW5ndGgpICYmIChzdHIgPT0gc2VhcmNoKSkgfHxcbiAgICAgICAgICAgICgoc3RyLmxlbmd0aCA+IHNlYXJjaC5sZW5ndGgpICYmIChzdHIuc3RhcnRzV2l0aChzZWFyY2ggKyAnICcpKSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRLZXlCeVZhbHVlKG9iaiwgdmFsdWUpIHtcbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgICAgICBpZiAob2JqW3Byb3BdID09PSB2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZXhwb3J0cy5VdGlscyA9IFV0aWxzO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==